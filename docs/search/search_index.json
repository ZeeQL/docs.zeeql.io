{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ZeeQL Documentation Work in progress. Stay tuned. Dramatically deploy top-line functionalities before robust processes. Intrinsicly harness client-based \"outside the box\" thinking rather than ethical customer service. Dramatically extend cooperative alignments without holistic sources. Conveniently visualize unique alignments before low-risk high-yield expertise. Completely mesh interoperable expertise after extensible imperatives. Conveniently benchmark backend supply chains and dynamic sources. Holisticly reintermediate vertical content after functional best practices. Professionally syndicate granular mindshare for adaptive process improvements. Efficiently myocardinate mission-critical leadership vis-a-vis competitive markets. Dramatically brand equity invested scenarios and best-of-breed meta-services. Interactively evisculate flexible synergy and technically sound platforms. Seamlessly grow future-proof expertise rather than premium potentialities. Uniquely leverage other's flexible niche markets with emerging functionalities. Credibly deliver extensible opportunities without functional initiatives.","title":"Introduction"},{"location":"#zeeql-documentation","text":"Work in progress. Stay tuned. Dramatically deploy top-line functionalities before robust processes. Intrinsicly harness client-based \"outside the box\" thinking rather than ethical customer service. Dramatically extend cooperative alignments without holistic sources. Conveniently visualize unique alignments before low-risk high-yield expertise. Completely mesh interoperable expertise after extensible imperatives. Conveniently benchmark backend supply chains and dynamic sources. Holisticly reintermediate vertical content after functional best practices. Professionally syndicate granular mindshare for adaptive process improvements. Efficiently myocardinate mission-critical leadership vis-a-vis competitive markets. Dramatically brand equity invested scenarios and best-of-breed meta-services. Interactively evisculate flexible synergy and technically sound platforms. Seamlessly grow future-proof expertise rather than premium potentialities. Uniquely leverage other's flexible niche markets with emerging functionalities. Credibly deliver extensible opportunities without functional initiatives.","title":"ZeeQL Documentation"},{"location":"about/","text":"Contact Hey, we love feedback. Join the mailing list, Slack channel or just drop us an email to tell us why this is crap (or not?). Mailing List Slack info@zeeql.io MkDocs Built with MkDocs using a theme provided by Read the Docs . Who ZeeQL is brought to you by the ZeeZide GmbH. Imprint .","title":"About"},{"location":"about/#contact","text":"Hey, we love feedback. Join the mailing list, Slack channel or just drop us an email to tell us why this is crap (or not?). Mailing List Slack info@zeeql.io","title":"Contact"},{"location":"about/#mkdocs","text":"Built with MkDocs using a theme provided by Read the Docs .","title":"MkDocs"},{"location":"about/#who","text":"ZeeQL is brought to you by the ZeeZide GmbH. Imprint .","title":"Who"},{"location":"design/","text":"ZeeQL Framework Design Work in progress. Stay tuned. ZeeQL is a Swift ORM / database access library primarily inspired by EOF, and in consequence CoreData. Adding some ActiveRecord ideas. The basic setup is that Access has two levels of abstraction: - adaptor level ( Adaptor , AdaptorChannel ) - database level ( Database , DatabaseChannel , DatabaseDataSource ) In general it is recommended to write a Model or a Model pattern, and then use the DatabaseDataSource to fetch mapped objects. However, for simple SQL you can also do that in rather convenient ways at the adaptor level. Important: to inject raw SQL you don't have to go down to adaptor level. You have various ways to embed SQL in the model and thats the recommended way to do it. Raw SQL Injection Notes . Adaptor Level The adaptor level is a relatively thin wrapper around the client libs, e.g. Apache DBD, which provides some convenience methods, model reflection etc. TBD: document Database Level TBD: document","title":"Design"},{"location":"design/#zeeql-framework-design","text":"Work in progress. Stay tuned. ZeeQL is a Swift ORM / database access library primarily inspired by EOF, and in consequence CoreData. Adding some ActiveRecord ideas. The basic setup is that Access has two levels of abstraction: - adaptor level ( Adaptor , AdaptorChannel ) - database level ( Database , DatabaseChannel , DatabaseDataSource ) In general it is recommended to write a Model or a Model pattern, and then use the DatabaseDataSource to fetch mapped objects. However, for simple SQL you can also do that in rather convenient ways at the adaptor level. Important: to inject raw SQL you don't have to go down to adaptor level. You have various ways to embed SQL in the model and thats the recommended way to do it. Raw SQL Injection Notes .","title":"ZeeQL Framework Design"},{"location":"design/#adaptor-level","text":"The adaptor level is a relatively thin wrapper around the client libs, e.g. Apache DBD, which provides some convenience methods, model reflection etc. TBD: document","title":"Adaptor Level"},{"location":"design/#database-level","text":"TBD: document","title":"Database Level"},{"location":"embedsql/","text":"Raw SQL Injection Notes Work in progress. Stay tuned. When your database schema becomes more complex, you may want to embed raw SQL in your ORM queries. ZeeQL supports various ways to do this. TBD: cleanup & organize CustomQueryExpressionHintKey IMPORTANT : patterns use % (e.g. %(oid)s ), NOT the $abc syntax of Qualifier s - the hint is being processed by SQLExpression - you can also use SQLQualifier with SQLExpression (which uses the $abc binding syntax) Raw SQL Patterns If the 'CustomQueryExpressionHintKey' is set, the value of this key is processed as a keyvalue-format pattern to produce the SQL. SQLExpression will still prepare and provide the parts of the SQL (qualifiers, sorts) but the assembly will be done using the SQL pattern. Example: SELECT COUNT(*) FROM %(tables)s WHERE %(where)s %(limit)s Keys: - select eg SELECT or SELECT DISTINCT - columns eg BASE.lastname, BASE.firstname - tables eg BASE.customer - basetable eg customer - qualifier eg lastname LIKE 'Duck%' - orderings eg lastname ASC, firstname DESC - limit eg OFFSET 0 LIMIT 1 - lock eg FOR UPDATE - joins Compound: - where eg WHERE lastname LIKE 'Duck%' - andQualifier eg AND lastname LIKE 'Duck%' (nothing w/o qualifier) - orQualifier eg OR lastname LIKE 'Duck%' (nothing w/o qualifier) - orderby eg ORDER BY mod_date DESC (nothing w/o orderings) Note: when using joins in a query, the base table should be named 'BASE', so that all the other features can be used. CustomQueryExpressionHintKey is also set by DatabaseDataSource fetchObjectsFor(sql:) CustomQueryExpressionHintKeyBindPattern Example: %%(tables)s WHERE id = %(id)s In Code: fs.fetchSpecificationWith(bindings: [ \"id\": 1] ) => CustomQueryExpressionHintKey = %(tables)s WHERE id = 1; formatting is done using KeyValueStringFormatter.format() TBD, SEC: do we need to be careful about SQL injection? Usage in an XML Model: <fetch name=\"count\" rawrows=\"true\"> <sql pattern=\"true/false\"> %(select)s COUNT(*) FROM %(tables)s %(where)s </sql> </fetch> Important: when using patterns, you need to escape SQL keys twice, eg: %%(select)s COUNT(*) FROM %%(table)s WHERE oid=%(oid)i SQLQualifier Example: \"login = %@ OR SQL[balance IN $balance1, $balance2]\" The SQL qualifier is getting split into parts, in this case: - \"balance IN \" - $balance1 (QualifierVariable name=balance1) - \", \" - $balance2 (QualifierVariable name=balance2) It is being processed in SQLExpression (sqlStringForRawQualifier(q)), at this point all QualifierVariable's are resolved! (bindings to the FetchSpecification) Do not confuse SQL binding variables with FetchSpecification bindings! SQLValue To inject single values Currently only supported by SQLExpression.addUpdateListAttribute Example: let values = [ \"status\" : \"created\", \"modDate\" : RawSQLValue(\"NOW()\") ] let op = AdaptorOperation(entity) ... op.changedValues = values let affected = channel.performAdaptorOperationN(op) Attribute Formats One can also inject readformat / writeformat SQL, e.g. to change all values to lowercase on writes: writeformat=\"LOWER(TRIM(%P))\" or case-stuff, like:: readformat=\"CASE %P WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' END\"","title":"Embed SQL"},{"location":"embedsql/#raw-sql-injection-notes","text":"Work in progress. Stay tuned. When your database schema becomes more complex, you may want to embed raw SQL in your ORM queries. ZeeQL supports various ways to do this. TBD: cleanup & organize","title":"Raw SQL Injection Notes"},{"location":"embedsql/#customqueryexpressionhintkey","text":"IMPORTANT : patterns use % (e.g. %(oid)s ), NOT the $abc syntax of Qualifier s - the hint is being processed by SQLExpression - you can also use SQLQualifier with SQLExpression (which uses the $abc binding syntax) Raw SQL Patterns If the 'CustomQueryExpressionHintKey' is set, the value of this key is processed as a keyvalue-format pattern to produce the SQL. SQLExpression will still prepare and provide the parts of the SQL (qualifiers, sorts) but the assembly will be done using the SQL pattern. Example: SELECT COUNT(*) FROM %(tables)s WHERE %(where)s %(limit)s Keys: - select eg SELECT or SELECT DISTINCT - columns eg BASE.lastname, BASE.firstname - tables eg BASE.customer - basetable eg customer - qualifier eg lastname LIKE 'Duck%' - orderings eg lastname ASC, firstname DESC - limit eg OFFSET 0 LIMIT 1 - lock eg FOR UPDATE - joins Compound: - where eg WHERE lastname LIKE 'Duck%' - andQualifier eg AND lastname LIKE 'Duck%' (nothing w/o qualifier) - orQualifier eg OR lastname LIKE 'Duck%' (nothing w/o qualifier) - orderby eg ORDER BY mod_date DESC (nothing w/o orderings) Note: when using joins in a query, the base table should be named 'BASE', so that all the other features can be used. CustomQueryExpressionHintKey is also set by DatabaseDataSource fetchObjectsFor(sql:)","title":"CustomQueryExpressionHintKey"},{"location":"embedsql/#customqueryexpressionhintkeybindpattern","text":"Example: %%(tables)s WHERE id = %(id)s In Code: fs.fetchSpecificationWith(bindings: [ \"id\": 1] ) => CustomQueryExpressionHintKey = %(tables)s WHERE id = 1; formatting is done using KeyValueStringFormatter.format() TBD, SEC: do we need to be careful about SQL injection? Usage in an XML Model: <fetch name=\"count\" rawrows=\"true\"> <sql pattern=\"true/false\"> %(select)s COUNT(*) FROM %(tables)s %(where)s </sql> </fetch> Important: when using patterns, you need to escape SQL keys twice, eg: %%(select)s COUNT(*) FROM %%(table)s WHERE oid=%(oid)i","title":"CustomQueryExpressionHintKeyBindPattern"},{"location":"embedsql/#sqlqualifier","text":"Example: \"login = %@ OR SQL[balance IN $balance1, $balance2]\" The SQL qualifier is getting split into parts, in this case: - \"balance IN \" - $balance1 (QualifierVariable name=balance1) - \", \" - $balance2 (QualifierVariable name=balance2) It is being processed in SQLExpression (sqlStringForRawQualifier(q)), at this point all QualifierVariable's are resolved! (bindings to the FetchSpecification) Do not confuse SQL binding variables with FetchSpecification bindings!","title":"SQLQualifier"},{"location":"embedsql/#sqlvalue","text":"To inject single values Currently only supported by SQLExpression.addUpdateListAttribute Example: let values = [ \"status\" : \"created\", \"modDate\" : RawSQLValue(\"NOW()\") ] let op = AdaptorOperation(entity) ... op.changedValues = values let affected = channel.performAdaptorOperationN(op)","title":"SQLValue"},{"location":"embedsql/#attribute-formats","text":"One can also inject readformat / writeformat SQL, e.g. to change all values to lowercase on writes: writeformat=\"LOWER(TRIM(%P))\" or case-stuff, like:: readformat=\"CASE %P WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' END\"","title":"Attribute Formats"},{"location":"install/","text":"ZeeQL Installation WORK IN PROGRESS, STAY TUNED Install on Linux Ubuntu packages required (assuming you have Swift 3 installed already): sudo apt-get update sudo apt-get install libsqlite3-dev To compile the standalone PostgreSQL driver: sudo apt-get install libpq-dev When using mod_dbd, mod_dbd drivers can be installed as desired: sudo apt-get install \\ libaprutil1-dbd-sqlite3 \\ libaprutil1-dbd-pgsql WORK IN PROGRESS, STAY TUNED APR Driver Homebrew Select the mod_dbd drivers you need: brew reinstall apr-util \\ --with-sqlite \\ --with-mysql \\ --with-postgresql WORK IN PROGRESS, STAY TUNED","title":"ZeeQL Installation"},{"location":"install/#zeeql-installation","text":"WORK IN PROGRESS, STAY TUNED","title":"ZeeQL Installation"},{"location":"install/#install-on-linux","text":"Ubuntu packages required (assuming you have Swift 3 installed already): sudo apt-get update sudo apt-get install libsqlite3-dev To compile the standalone PostgreSQL driver: sudo apt-get install libpq-dev When using mod_dbd, mod_dbd drivers can be installed as desired: sudo apt-get install \\ libaprutil1-dbd-sqlite3 \\ libaprutil1-dbd-pgsql WORK IN PROGRESS, STAY TUNED","title":"Install on Linux"},{"location":"install/#apr-driver","text":"","title":"APR Driver"},{"location":"install/#homebrew","text":"Select the mod_dbd drivers you need: brew reinstall apr-util \\ --with-sqlite \\ --with-mysql \\ --with-postgresql WORK IN PROGRESS, STAY TUNED","title":"Homebrew"},{"location":"settings/","text":"Environment Variables Work in progress. Stay tuned. Logging Level You can configure the level of the global ZeeQL logger using the ZEEQL_LOGLEVEL environment variable, for example in your run scheme. Valid values are: error warn info trace log","title":"Settings"},{"location":"settings/#environment-variables","text":"Work in progress. Stay tuned.","title":"Environment Variables"},{"location":"settings/#logging-level","text":"You can configure the level of the global ZeeQL logger using the ZEEQL_LOGLEVEL environment variable, for example in your run scheme. Valid values are: error warn info trace log","title":"Logging Level"},{"location":"troubleshooting/","text":"Troubleshooting Work in progress. Stay tuned. Compilation Errors If you get: Could not build Objective-C module 'APR' : If you want to use the APR database drivers, install APR, e.g. using HomeBrew: brew install apr-util --with-openldap --with-postgresql --with-sqlite","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"Work in progress. Stay tuned.","title":"Troubleshooting"},{"location":"troubleshooting/#compilation-errors","text":"If you get: Could not build Objective-C module 'APR' : If you want to use the APR database drivers, install APR, e.g. using HomeBrew: brew install apr-util --with-openldap --with-postgresql --with-sqlite","title":"Compilation Errors"}]}